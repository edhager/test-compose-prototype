{"version":3,"file":"compose.js","sourceRoot":"","sources":["compose.ts"],"names":["rebase","stamp","cloneCreator","cloneCreator.Creator","extend","mixin","overlay","from","doFrom","before","doBefore","after","doAfter","around","doAround","aspect","aspect.mapAdvice","create"],"mappings":"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","sourcesContent":["import WeakMap from 'dojo-core/WeakMap';\r\nimport { assign } from 'dojo-core/lang';\r\nimport {\r\n\tbefore as aspectBefore,\r\n\tafter as aspectAfter,\r\n\taround as aspectAround,\r\n\tBeforeAdvice,\r\n\tAfterAdvice,\r\n\tAroundAdvice\r\n} from './aspect';\r\n\r\n/* A weakmap that will store initialization functions for compose constructors */\r\nconst initFnMap = new WeakMap<Function, ComposeInitializationFunction<any>[]>();\r\n\r\n/**\r\n * A helper funtion to return a function that is rebased\r\n * @param  {Function} fn The function to be rebased\r\n * @return {Function}    The rebased function\r\n */\r\nfunction rebase(fn: Function): Function {\r\n   return function(...args: any[]) {\r\n\t   return fn.apply(this, [ this ].concat(args));\r\n   };\r\n}\r\n\r\n/* The rebased functions we need to decorate compose constructors with */\r\nconst doExtend = rebase(extend);\r\nconst doMixin = rebase(mixin);\r\nconst doOverlay = rebase(overlay);\r\nconst doAspect = rebase(aspect);\r\n\r\n/**\r\n * A convience function to decorate a compose class constructors\r\n * @param {any} base The target constructor\r\n */\r\nfunction stamp(base: any): void {\r\n   base.extend = doExtend;\r\n   base.mixin = doMixin;\r\n   base.overlay = doOverlay;\r\n   base.from = doFrom;\r\n   base.before = doBefore;\r\n   base.after = doAfter;\r\n   base.around = doAround;\r\n   base.aspect = doAspect;\r\n}\r\n\r\n/**\r\n * Take a compose constructor and clone it\r\n * @param  {ComposeClass<O, T>} base The base to clone\r\n * @return {ComposeClass<O, T>}      The cloned constructor function\r\n */\r\nfunction cloneCreator<O, T>(base?: ComposeClass<O, T>): ComposeClass<O, T>;\r\nfunction cloneCreator(base?: any): any {\r\n\tfunction Creator(...args: any[]): any {\r\n\t\tinitFnMap.get(this.constructor).forEach(fn => fn.apply(this, args));\r\n\t}\r\n\r\n\tif (base) {\r\n\t\tassign(Creator.prototype, base.prototype);\r\n\t\tinitFnMap.set(Creator, [].concat(initFnMap.get(base)));\r\n\t}\r\n\telse {\r\n\t\tinitFnMap.set(Creator, []);\r\n\t}\r\n\tCreator.prototype.constructor = Creator;\r\n\tstamp(Creator);\r\n\tObject.freeze(Creator);\r\n\r\n\treturn Creator;\r\n}\r\n\r\n/* General Interfaces */\r\n\r\nexport interface GenericClass<T> {\r\n\tnew (...args: any[]): T;\r\n\tprototype: T;\r\n}\r\n\r\nexport interface ComposeInitializationFunction<O> {\r\n\t(options?: O): void;\r\n}\r\n\r\n/* Extension API */\r\nexport interface ComposeClass<O, T> {\r\n\textend<U>(extension: U): ComposeClass<O, T & U>;\r\n}\r\n\r\nexport interface Compose {\r\n\textend<O, A, B>(base: ComposeClass<O, A>, extension: B): ComposeClass<O, A & B>;\r\n}\r\n\r\nfunction extend<O, A, B>(base: ComposeClass<O, A>, extension: B): ComposeClass<O, A & B>;\r\nfunction extend<O>(base: ComposeClass<O, any>, extension: any): ComposeClass<O, any> {\r\n\tbase = cloneCreator(base);\r\n\tObject.keys(extension).forEach(key => base.prototype[key] = extension[key]);\r\n\tObject.freeze(base.prototype);\r\n\treturn base;\r\n}\r\n\r\n/* Mixin API */\r\nexport interface ComposeClass<O, T> {\r\n\tmixin<P, U>(mixin: GenericClass<U>): ComposeClass<O, T & U>;\r\n\tmixin<P, U>(mixin: ComposeClass<P, U>): ComposeClass<O&P, T & U>;\r\n}\r\n\r\nexport interface Compose {\r\n\tmixin<O, A, B>(base: ComposeClass<O, A>, mixin: GenericClass<B>): ComposeClass<O, A & B>;\r\n\tmixin<O, P, A, B>(base: ComposeClass<O, A>, mixin: ComposeClass<P, B>): ComposeClass<O & P, A & B>;\r\n}\r\n\r\nfunction mixin<O, A, B>(base: ComposeClass<O, A>, mixin: GenericClass<B>): ComposeClass<O, A & B>;\r\nfunction mixin<O, P, A, B>(base: ComposeClass<O, A>, mixin: ComposeClass<P, B>): ComposeClass<O & P, A & B>;\r\nfunction mixin<O>(base: ComposeClass<O, any>, mixin: any): ComposeClass<O, any> {\r\n\tbase = cloneCreator(base);\r\n\tObject.keys(mixin.prototype).forEach(key => base.prototype[key] = mixin.prototype[key]);\r\n\tObject.freeze(base.prototype);\r\n\treturn base;\r\n}\r\n\r\n/* Overlay API */\r\nexport interface OverlayFunction<T> {\r\n\t(proto: T): void;\r\n}\r\n\r\nexport interface ComposeClass<O, T> {\r\n\t overlay(overlayFunction: OverlayFunction<T>): ComposeClass<O, T>;\r\n}\r\n\r\nexport interface Compose {\r\n\toverlay<O, A>(base: ComposeClass<O, A>, overlayFunction: OverlayFunction<A>): ComposeClass<O, A>;\r\n}\r\n\r\nfunction overlay<O, A>(base: ComposeClass<O, A>, overlayFunction: OverlayFunction<A>): ComposeClass<O, A> {\r\n\tbase = cloneCreator(base);\r\n\toverlayFunction(base.prototype);\r\n\treturn base;\r\n}\r\n\r\n/* AOP/Inheritance API */\r\n\r\nexport interface AspectAdvice {\r\n\tbefore?: { [method: string]: BeforeAdvice };\r\n\tafter?: { [method: string]: AfterAdvice<any> };\r\n\taround?: { [method: string]: AroundAdvice<any> };\r\n}\r\n\r\nexport interface GenericFunction<T> {\r\n\t(...args: any[]): T;\r\n}\r\n\r\nexport interface ComposeClass<O, T> {\r\n\tfrom(base: GenericClass<any>, method: string): ComposeClass<O, T>;\r\n\tfrom(base: ComposeClass<any, any>, method: string): ComposeClass<O, T>;\r\n\r\n\tbefore(method: string, advice: BeforeAdvice): ComposeClass<O, T>;\r\n\tafter<P>(method: string, advice: AfterAdvice<P>): ComposeClass<O, T>;\r\n\taround<P>(method: string, advice: AroundAdvice<P>): ComposeClass<O, T>;\r\n\r\n\taspect(advice: AspectAdvice): ComposeClass<O, T>;\r\n}\r\n\r\nexport interface Compose {\r\n\tfrom<T extends Function>(base: GenericClass<any>, method: string): T;\r\n\tfrom<T extends Function>(base: ComposeClass<any, any>, method: string): T;\r\n\r\n\tbefore<T>(base: GenericClass<any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\r\n\tbefore<T>(base: ComposeClass<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\r\n\tbefore<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\r\n\r\n\tafter<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\n\tafter<T>(base: ComposeClass<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\n\tafter<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\r\n\r\n\taround<T>(base: GenericClass<any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;\r\n\taround<T>(base: ComposeClass<any, any>, method: string, advice: AroundAdvice<T>): GenericFunction<T>;\r\n\taround<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\r\n\r\n\taspect<O, A>(base: ComposeClass<O, A>, advice: AspectAdvice): ComposeClass<O, A>;\r\n}\r\n\r\nfunction from<T extends Function>(base: GenericClass<any>, method: string): T;\r\nfunction from<T extends Function>(base: ComposeClass<any, any>, method: string): T;\r\nfunction from<T extends Function>(base: any, method: string): T {\r\n\treturn base.prototype[method];\r\n}\r\n\r\nfunction doFrom<O, T>(base: GenericClass<any>, method: string): ComposeClass<O, T>;\r\nfunction doFrom<O, T>(base: ComposeClass<any, any>, method: string): ComposeClass<O, T>;\r\nfunction doFrom(base: any, method: string): ComposeClass<any, any> {\r\n\tconst clone = cloneCreator(this);\r\n\t(<any> clone.prototype)[method] = base.prototype[method];\r\n\treturn clone;\r\n}\r\n\r\nfunction before<T>(base: GenericClass<any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\r\nfunction before<T>(base: ComposeClass<any, any>, method: string, advice: BeforeAdvice): GenericFunction<T>;\r\nfunction before<T>(method: GenericFunction<T>, advice: BeforeAdvice): GenericFunction<T>;\r\nfunction before(...args: any[]): GenericFunction<any> {\r\n\tlet base: GenericFunction<any>;\r\n\tlet method: string | GenericFunction<any>;\r\n\tlet advice: BeforeAdvice;\r\n\tif (args.length >= 3) {\r\n\t\t[ base, method, advice ] = args;\r\n\t\tmethod = base.prototype[<string> method];\r\n\t}\r\n\telse {\r\n\t\t[ method, advice ] = args;\r\n\t}\r\n\treturn aspectBefore(<GenericFunction<any>> method, advice);\r\n}\r\n\r\nfunction doBefore<O, T>(method: string, advice: BeforeAdvice): ComposeClass<O, T> {\r\n\tconst clone = cloneCreator(this);\r\n\t(<any> clone.prototype)[method] = aspectBefore((<any> clone.prototype)[method], advice);\r\n\treturn <ComposeClass<O, T>> clone;\r\n}\r\n\r\nfunction after<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction after<T>(base: ComposeClass<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction after<T>(method: GenericFunction<T>, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction after(...args: any[]): GenericFunction<any> {\r\n\tlet base: GenericFunction<any>;\r\n\tlet method: string | GenericFunction<any>;\r\n\tlet advice: AfterAdvice<any>;\r\n\tif (args.length >= 3) {\r\n\t\t[ base, method, advice ] = args;\r\n\t\tmethod = base.prototype[<string> method];\r\n\t}\r\n\telse {\r\n\t\t[ method, advice ] = args;\r\n\t}\r\n\treturn aspectAfter(<GenericFunction<any>> method, advice);\r\n}\r\n\r\nfunction doAfter<O, P, T>(method: string, advice: AfterAdvice<P>): ComposeClass<O, T> {\r\n\tconst clone = cloneCreator(this);\r\n\t(<any> clone.prototype)[method] = aspectAfter((<any> clone.prototype)[method], advice);\r\n\treturn <ComposeClass <O, T>> clone;\r\n}\r\n\r\nfunction around<T>(base: GenericClass<any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction around<T>(base: ComposeClass<any, any>, method: string, advice: AfterAdvice<T>): GenericFunction<T>;\r\nfunction around<T>(method: GenericFunction<T>, advice: AroundAdvice<T>): GenericFunction<T>;\r\nfunction around(...args: any[]): GenericFunction<any> {\r\n\tlet base: GenericFunction<any>;\r\n\tlet method: string | GenericFunction<any>;\r\n\tlet advice: AfterAdvice<any>;\r\n\tif (args.length >= 3) {\r\n\t\t[ base, method, advice ] = args;\r\n\t\tmethod = base.prototype[<string> method];\r\n\t}\r\n\telse {\r\n\t\t[ method, advice ] = args;\r\n\t}\r\n\treturn aspectAround(<GenericFunction<any>> method, advice);\r\n}\r\n\r\nfunction doAround<O, P, T>(method: string, advice: AroundAdvice<P>): ComposeClass<O, T> {\r\n\tconst clone = cloneCreator(this);\r\n\t(<any> clone.prototype)[method] = aspectAround((<any> clone.prototype)[method], advice);\r\n\treturn <ComposeClass <O, T>> clone;\r\n}\r\n\r\nfunction aspect<O, A>(base: ComposeClass<O, A>, advice: AspectAdvice): ComposeClass<O, A> {\r\n\tconst clone = cloneCreator(base);\r\n\r\n\tfunction mapAdvice(adviceHash: { [method: string ]: Function }, advisor: Function): void {\r\n\t\tfor (let key in adviceHash) {\r\n\t\t\tif (key in clone.prototype) {\r\n\t\t\t\t(<any> clone.prototype)[key] = advisor((<any> clone.prototype)[key], adviceHash[key]);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthrow new Error('Trying to advise non-existing method: \"' + key + '\"');\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (advice.before) {\r\n\t\tmapAdvice(advice.before, before);\r\n\t}\r\n\tif (advice.after) {\r\n\t\tmapAdvice(advice.after, after);\r\n\t}\r\n\tif (advice.around) {\r\n\t\tmapAdvice(advice.around, around);\r\n\t}\r\n\treturn clone;\r\n}\r\n\r\n/* Creation API */\r\nexport interface ComposeClass<O, T> {\r\n\tnew (options?: O): T;\r\n\tprototype: T;\r\n}\r\n\r\nexport interface Compose {\r\n\t<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O>): ComposeClass<O, A>;\r\n\t<O, A, P>(base: ComposeClass<O, A>, initFunction?: ComposeInitializationFunction<P>): ComposeClass<O & P, A>;\r\n\t<O, A>(base: A, initFunction?: ComposeInitializationFunction<O>): ComposeClass<O, A>;\r\n\tcreate<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O>): ComposeClass<O, A>;\r\n\tcreate<O, A, P>(base: ComposeClass<O, A>, initFunction?: ComposeInitializationFunction<P>): ComposeClass<O & P, A>;\r\n\tcreate<O, A>(base: A, initFunction?: ComposeInitializationFunction<O>): ComposeClass<O, A>;\r\n}\r\n\r\nfunction create<O, A>(base: GenericClass<A>, initFunction?: ComposeInitializationFunction<O>): ComposeClass<O, A>;\r\nfunction create<O, A, P>(base: ComposeClass<O, A>, initFunction?: ComposeInitializationFunction<P>): ComposeClass<O & P, A>;\r\nfunction create<O, A>(base: A, initFunction?: ComposeInitializationFunction<O>): ComposeClass<O, A>;\r\nfunction create<O>(base: any, initFunction?: ComposeInitializationFunction<O>): any {\r\n\tconst Creator = cloneCreator();\r\n\tif (initFunction) {\r\n\t\tinitFnMap.get(Creator).push(initFunction);\r\n\t}\r\n\r\n\t/* mixin the base into the prototype */\r\n\tassign(Creator.prototype, typeof base === 'function' ? base.prototype : base);\r\n\r\n   /* return the new constructor */\r\n   return Creator;\r\n}\r\n\r\n/* Generate compose */\r\n(<Compose> create).create = create;\r\n(<Compose> create).extend = extend;\r\n(<Compose> create).mixin = mixin;\r\n(<Compose> create).overlay = overlay;\r\n(<Compose> create).from = from;\r\n(<Compose> create).before = before;\r\n(<Compose> create).after = after;\r\n(<Compose> create).around = around;\r\n(<Compose> create).aspect = aspect;\r\n\r\nconst compose: Compose = <Compose> create;\r\n\r\nexport default compose;\r\n"]}